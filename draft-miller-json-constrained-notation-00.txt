



                                                               J. Miller

                                                          P. Saint-Andre
                                                             May 5, 2017


                    JSON Constrained Notation (JSCN)
                                 draft

Abstract

   This specification addresses the challenges of using JavaScript
   Object Notation (JSON) with constrained devices by providing a set of
   mapping rules to Concise Binary Object Representation (CBOR) that
   preserve all semantic information, such that the original JSON string
   can be identically re-created.  JSON Constrained Notation can be used
   directly by devices as a native data format, which can be represented
   as JSON when necessary for diagnostics, compatibility, and ease of
   integration with higher-level systems.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  CBOR Encoding . . . . . . . . . . . . . . . . . . . . . . . .   3
     2.1.  Structured Types  . . . . . . . . . . . . . . . . . . . .   3
     2.2.  Primitive Types . . . . . . . . . . . . . . . . . . . . .   4
       2.2.1.  Boolean and Null  . . . . . . . . . . . . . . . . . .   4
       2.2.2.  Numbers . . . . . . . . . . . . . . . . . . . . . . .   4
       2.2.3.  Strings . . . . . . . . . . . . . . . . . . . . . . .   4
   3.  Reference Sets  . . . . . . . . . . . . . . . . . . . . . . .   5
   4.  Whitespace Hints  . . . . . . . . . . . . . . . . . . . . . .   5
   5.  Constrained API . . . . . . . . . . . . . . . . . . . . . . .   6
   6.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .   6
     6.1.  JSON  . . . . . . . . . . . . . . . . . . . . . . . . . .   6
       6.1.1.  Input . . . . . . . . . . . . . . . . . . . . . . . .   6
       6.1.2.  Optimized JSCN Encoding . . . . . . . . . . . . . . .   7
       6.1.3.  Unoptimized JSCN Encoding . . . . . . . . . . . . . .   9
     6.2.  JSON Web Token  . . . . . . . . . . . . . . . . . . . . .  11
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  12
     7.1.  CBOR Tags . . . . . . . . . . . . . . . . . . . . . . . .  12
     7.2.  JSCN Reference Sets Registry  . . . . . . . . . . . . . .  13
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  13
   9.  Normative References  . . . . . . . . . . . . . . . . . . . .  13
   Appendix A.  Acknowledgements . . . . . . . . . . . . . . . . . .  14
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  14





Miller & Saint-Andre    Expires November 6, 2017                [Page 1]

                                  JSCN                          May 2017


1.  Introduction

   Although JavaScript Object Notation (JSON) [RFC7159] has been widely
   adopted in traditional networking and software environments, its use
   in embedded and constrained environments has been more limited
   because of the minimal storage and network capacities inherent in
   low-cost and low-power devices (see [RFC7228]).

   This specification addresses the challenges of using JSON with
   constrained devices by defining a set of mapping rules to Concise
   Binary Object Representation (CBOR) [RFC7049] that preserve all
   semantic information, such that the original JSON string can be
   identically re-created.  JSON Constrained Notation (JSCN) can be used
   directly by devices as a native data format, which can be represented
   as JSON when necessary for diagnostics, compatibility, and ease of
   integration with higher-level systems.

   A primary goal of JSCN is to enable all JSON Object Signing and
   Encryption (JOSE) standards ([RFC7515], [RFC7516], [RFC7517],
   [RFC7518], [RFC7519]) to be used unmodified in constrained
   environments.  One result is that OpenID Connect (which is based on
   JOSE) can be adopted as an identity management solution for the
   Internet of Things.

   JSCN is designed to leverage, not replace, CBOR.  Instead, JSCN
   specifies rules for re-coding JSON structures by mapping them to
   their CBOR parallels whenever possible, and then increasing the
   efficiency through introspection and replacement of well-known
   strings with compact references.

   All transcoding software must operate on a UTF-8 JSON string whenever
   complete round-trip compatibilityy to and from JSON is required,
   including mapping any contained non-structural whitespace (such as
   with JWTs for signature validation).  If a transcoder is only
   operating with an already parsed JSON value (the result of
   "JSON.parse()" in JavaScript for instance), the round-trip can only
   guarantee semantic compatibility of the values as represented in that
   parsed context (only the JavaScript object will always match).

   A significant reduction in space is also provided in JSCN when the
   device and application contexts can make use of built-in or shared
   UTF-8 string references.  These references provide a mapping of
   common JSON string values to an integer that used to replace the
   string in the resulting CBOR during re-coding.  JSON string values
   are also introspected for data that has a more compact CBOR type
   (such as base64url and hexadecimal encoding).





Miller & Saint-Andre    Expires November 6, 2017                [Page 2]

                                  JSCN                          May 2017


   This specification does not currently provide for the CBOR byte
   strings to be canonical and only guarantees that the JSON byte
   strings before and after re-coding will be identical.  It also
   defines basic API rules for constrained software such that accessing
   the CBOR data values will provide a uniform view even if the
   underlying CBOR has encoding differences.

1.1.  Terminology

   Many terms used in this document are defined in the specifications
   for JSON [RFC7159] and CBOR [RFC7049].  This specification defines
   the following additional terms:

   o  Reference

      *  A pointer within JSCN data that refers to a well-known UTF-8
         string by using a CBOR byte string of length one, where the
         byte value is the lookup identifier for the Reference.

   o  Reference Set

      *  A CBOR array of UTF-8 strings that are used to replace any
         Reference within any JSCN data, where the Reference identifier
         is the array offset to the replacement string and the first
         position in the array identifies the Reference Set.

   o  Whitespace Hints

      *  A CBOR array of integers that indicate positional offsets and
         types of JSON whitespace strings (, "\n", "\r", and "\t") such
         that when any CBOR encoded data is stringified into JSON it can
         also optionally be corrected to exactly match the original JSON
         string.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

2.  CBOR Encoding

   JSCN encodes JSON data types to CBOR data types as described in the
   following sections.

2.1.  Structured Types

   JSON defines two structured types: arrays and objects.  These are
   serialized to CBOR major type 4 (array) and type 5 (map),




Miller & Saint-Andre    Expires November 6, 2017                [Page 3]

                                  JSCN                          May 2017


   respectively.  Ordering of key/value pairs in JSON objects and CBOR
   maps MUST be preserved.

2.2.  Primitive Types

2.2.1.  Boolean and Null

   The JSON literal names "false", "true", and "null" are serialized to
   the CBOR major type 7 simple values 20, 21, and 22 respectively.

2.2.2.  Numbers

   A JSCN encoder attempts to encode a JSON number as a CBOR unsigned
   integer (type 0), negative integer (type 1), or float (type 7) and
   then test for compatibility by round-tripping the CBOR data item back
   to a JSON number.  If the resulting JSON number is not equivalent to
   the input number, the encoder MUST instead encode it as a CBOR
   Bigfloat (tag 5).

   The JSON exponent value (if any) is encoded as a CBOR exponent (tag
   4).  If the contained "e" symbol is upper case in JSON, the "Upper
   Case Modifier" tag defined below MUST be included.

2.2.3.  Strings

   A JSON string is encoded as a CBOR UTF-8 string (type 3), i.e., as a
   series of UTF-8 [RFC3629] characters (e.g., the word "one" is encoded
   as "6F6E65").  JSON string values MUST NOT be un-escaped and re-
   escaped unless the JSCN encoder is restricted by operating in a
   limited parsed context without any JSON compatibility guarantees.

2.2.3.1.  Base64 / Base16 Encoded

   A JSCN encoder MUST round-trip test all JSON strings for possible
   encodings (base64url, base64, and hexadecimal) by attempting to
   decode and re-encode them.  If identical byte strings result, the
   decoded value is tagged in CBOR with the encoding format (tags 21,
   22, and 23).  For hexadecimal, the "Upper Case Modifier" tag defined
   below MUST be included if the hexadecimal letters A-F are upper case
   in the original JSON string.

   A JSCN encoder MUST perform introspection on the resulting decoded
   byte string to determine if it begins with a JSON structure byte of
   '{' or '['.  The encoder SHOULD then round-trip test the string as a
   possible JSON object or array so that it can encode the string more
   efficiently into a CBOR data item instead of a byte string (this
   pattern is common in the JOSE specification).




Miller & Saint-Andre    Expires November 6, 2017                [Page 4]

                                  JSCN                          May 2017


3.  Reference Sets

   o  The "Constrained JSON" tag is followed by an array whose second
      item identifies the Reference Set used in the data.  This is
      either a Reference Set identifier or an array that defines an
      inline Reference Set.

   o  A Reference Set identifier is a unique integer that maps to a
      Reference Set known to applications using the set.  Public, well-
      known reference sets can be registered as described in the IANA
      Considerations section of this document.

   o  A Reference Set definition is encoded as a JSCN array, where the
      first value is the Reference Set identifier followed by all of the
      UTF-8 string keys.  A key's position in the array is the byte
      value with which it is replaced.

   o  A Reference Set can include another Reference Set by encoding the
      second set's identifer in the JSCN array that defines the first
      Reference Set.  Any byte strings in the definition array are then
      replaced with the key from the references contained in the second
      Reference Set.

   o  JSON UTF-8 strings representing keys or values are first checked
      against all active references (if any) for possible replacement.
      A replacement is always a CBOR byte string (type 2) of length 1,
      where the single byte represents the index value of the key in the
      references array from 1-255.  Value 0 and byte lengths greater
      than 1 are reserved for future use.

   o  When a JSCN decoder generates JSON values from CBOR and it
      encounters a CBOR byte string (type 2), single byte value MUST
      match the array offset of the active references to be used as the
      replacement for that byte string.

4.  Whitespace Hints

   o  Whitespace hints are an array containing integers that indicate
      offsets of the locations of whitespace in an original JSON string
      and lookup keys to what whitespace contents were there.

   o  Each offset integer is relative to the position of the previous
      offset such that all integers are of small values.

   o  A negative integer offset indicates a single ASCII space character
      (0x20) at the offset of the positive value of that integer.





Miller & Saint-Andre    Expires November 6, 2017                [Page 5]

                                  JSCN                          May 2017


   o  An unsigned integer offset is followed by another integer, where
      unsigned values (0-23) indicate a whitespace string in a pre-
      defined lookup table and negative values specify the number of
      space characters (0x20) to repeat.

   o  When adding back any whitespace to a JSON string the array must be
      applied sequentially so that each new offset matches the original
      JSON string position.

   (TODO embed whitespace lookup table and examples)

5.  Constrained API

   In order to ease the use of JSCN in contrained environments, an
   implementation should make data values available both as native types
   and as JSON strings; this enables a constrained application to choose
   either format regardless of how the CBOR types represent the data.

   For example, when a JSON string value is encoded in JSCN as a CBOR
   base64url tag plus byte string, a constrained application can then
   access either the original base64url string value or the CBOR binary
   byte string as needed, but should not alter behavior based on which
   way the value is encoded in CBOR.

6.  Examples

6.1.  JSON

6.1.1.  Input

   Consider the following JSON as input to a JSCN encoder.




















Miller & Saint-Andre    Expires November 6, 2017                [Page 6]

                                  JSCN                          May 2017


                           {
                             "map": "value",
                             "array": [
                               "one",
                               "two",
                               "three",
                               42
                             ],
                             "bool": true,
                             "neg": -42,
                             "simple": [
                               false,
                               null,
                               ""
                             ],
                             "ints": [
                               0,
                               1,
                               23,
                               24,
                               255,
                               256,
                               65535,
                               65536,
                               4294967295,
                               4294967296,
                               281474976710656,
                               -281474976710656
                             ]
                           }

6.1.2.  Optimized JSCN Encoding

   An optimized encoding would remove whitespace and use a Reference
   Set. Here the reference would be:

   "[1,"map","value","array","one","two","three","bool","neg","simple","
   ints"]"

   The resulting JSCN encoding is 90 bytes compared to 318 bytes for the
   JSON input.










Miller & Saint-Andre    Expires November 6, 2017                [Page 7]

                                  JSCN                          May 2017


        D4                              # tag(20)
           82                           # array(2)
              A6                        # map(6)
                 41                     # bytes(1)
                    01                  # "\x01"
                 41                     # bytes(1)
                    02                  # "\x02"
                 41                     # bytes(1)
                    03                  # "\x03"
                 84                     # array(4)
                    41                  # bytes(1)
                       04               # "\x04"
                    41                  # bytes(1)
                       05               # "\x05"
                    41                  # bytes(1)
                       06               # "\x06"
                    18 2A               # unsigned(42)
                 41                     # bytes(1)
                    07                  # "\a"
                 F5                     # primitive(21)
                 41                     # bytes(1)
                    08                  # "\b"
                 38 29                  # negative(41)
                 41                     # bytes(1)
                    09                  # "\t"
                 83                     # array(3)
                    F4                  # primitive(20)
                    F6                  # primitive(22)
                    60                  # text(0)
                                        # ""
                 41                     # bytes(1)
                    0A                  # "\n"
                 8C                     # array(12)
                    00                  # unsigned(0)
                    01                  # unsigned(1)
                    17                  # unsigned(23)
                    18 18               # unsigned(24)
                    19 00FF             # unsigned(255)
                    19 0100             # unsigned(256)
                    19 FFFF             # unsigned(65535)
                    1A 00010000         # unsigned(65536)
                    1B 00000000FFFFFFFF # unsigned(4294967295)
                    1B 0000000100000000 # unsigned(4294967296)
                    1B 0001000000000000 # unsigned(281474976710656)
                    3B 0000FFFFFFFFFFFF # negative(281474976710655)
              01                        # unsigned(1)





Miller & Saint-Andre    Expires November 6, 2017                [Page 8]

                                  JSCN                          May 2017


6.1.3.  Unoptimized JSCN Encoding

   An unoptimized encoding would not use a Reference Set and would
   preserve whitespace.  The unoptimized encoding would reduce the data
   from the 318 bytes (JSON) to 187 bytes (JSCN).

        D4                              # tag(20)
           83                           # array(3)
              A6                        # map(6)
                 63                     # text(3)
                    6D6170              # "map"
                 65                     # text(5)
                    76616C7565          # "value"
                 65                     # text(5)
                    6172726179          # "array"
                 84                     # array(4)
                    63                  # text(3)
                       6F6E65           # "one"
                    63                  # text(3)
                       74776F           # "two"
                    65                  # text(5)
                       7468726565       # "three"
                    18 2A               # unsigned(42)
                 64                     # text(4)
                    626F6F6C            # "bool"
                 F5                     # primitive(21)
                 63                     # text(3)
                    6E6567              # "neg"
                 38 29                  # negative(41)
                 66                     # text(6)
                    73696D706C65        # "simple"
                 83                     # array(3)
                    F4                  # primitive(20)
                    F6                  # primitive(22)
                    60                  # text(0)
                                        # ""
                 64                     # text(4)
                    696E7473            # "ints"
                 8C                     # array(12)
                    00                  # unsigned(0)
                    01                  # unsigned(1)
                    17                  # unsigned(23)
                    18 18               # unsigned(24)
                    19 00FF             # unsigned(255)
                    19 0100             # unsigned(256)
                    19 FFFF             # unsigned(65535)
                    1A 00010000         # unsigned(65536)
                    1B 00000000FFFFFFFF # unsigned(4294967295)



Miller & Saint-Andre    Expires November 6, 2017                [Page 9]

                                  JSCN                          May 2017


                    1B 0000000100000000 # unsigned(4294967296)
                    1B 0001000000000000 # unsigned(281474976710656)
                    3B 0000FFFFFFFFFFFF # negative(281474976710655)
              00                        # unsigned(0)
              98 40                     # array(64)
                 01                     # unsigned(1)
                 01                     # unsigned(1)
                 26                     # negative(6)
                 08                     # unsigned(8)
                 01                     # unsigned(1)
                 28                     # negative(8)
                 01                     # unsigned(1)
                 02                     # unsigned(2)
                 06                     # unsigned(6)
                 02                     # unsigned(2)
                 06                     # unsigned(6)
                 02                     # unsigned(2)
                 08                     # unsigned(8)
                 02                     # unsigned(2)
                 02                     # unsigned(2)
                 01                     # unsigned(1)
                 02                     # unsigned(2)
                 01                     # unsigned(1)
                 27                     # negative(7)
                 05                     # unsigned(5)
                 01                     # unsigned(1)
                 26                     # negative(6)
                 04                     # unsigned(4)
                 01                     # unsigned(1)
                 29                     # negative(9)
                 01                     # unsigned(1)
                 02                     # unsigned(2)
                 06                     # unsigned(6)
                 02                     # unsigned(2)
                 05                     # unsigned(5)
                 02                     # unsigned(2)
                 02                     # unsigned(2)
                 01                     # unsigned(1)
                 02                     # unsigned(2)
                 01                     # unsigned(1)
                 27                     # negative(7)
                 01                     # unsigned(1)
                 02                     # unsigned(2)
                 02                     # unsigned(2)
                 02                     # unsigned(2)
                 02                     # unsigned(2)
                 02                     # unsigned(2)
                 03                     # unsigned(3)



Miller & Saint-Andre    Expires November 6, 2017               [Page 10]

                                  JSCN                          May 2017


                 02                     # unsigned(2)
                 03                     # unsigned(3)
                 02                     # unsigned(2)
                 04                     # unsigned(4)
                 02                     # unsigned(2)
                 04                     # unsigned(4)
                 02                     # unsigned(2)
                 06                     # unsigned(6)
                 02                     # unsigned(2)
                 06                     # unsigned(6)
                 02                     # unsigned(2)
                 0B                     # unsigned(11)
                 02                     # unsigned(2)
                 0B                     # unsigned(11)
                 02                     # unsigned(2)
                 10                     # unsigned(16)
                 02                     # unsigned(2)
                 10                     # unsigned(16)
                 01                     # unsigned(1)
                 01                     # unsigned(1)
                 00                     # unsigned(0)

6.2.  JSON Web Token

   Consider the following JSON Web Token [RFC7519], which natively is
   149 bytes (line endings are not significant):

              eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiO
              iIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWR
              taW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZ
              geFONFh7HgQ

   In a JSON encoding, the JWT would be 191 bytes (line endings are not
   significant):

                 {"protected":
                 "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
                 "payload":"eyJzdWIiOiIxMjM0NTY3ODkwIiwib
                 mFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9",
                 "signature":
                 "TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh
                 7HgQ"}

   Using a Reference Set of "[1,"payload","signature","protected","alg",
   "HS256","sub","name","admin"]", the JSCN encoding would be 80 bytes.






Miller & Saint-Andre    Expires November 6, 2017               [Page 11]

                                  JSCN                          May 2017


        D4                                      # tag(20)
           82                                   # array(2)
              A3                                # map(3)
                 41                             # bytes(1)
                    03                          # "\x03"
                 D5                             # tag(21)
                    A2                          # map(2)
                       41                       # bytes(1)
                          04                    # "\x04"
                       41                       # bytes(1)
                          05                    # "\x05"
                       41                       # bytes(1)
                          06                    # "\x06"
                       41                       # bytes(1)
                          07                    # "\a"
                 41                             # bytes(1)
                    01                          # "\x01"
                 D5                             # tag(21)
                    A3                          # map(3)
                       41                       # bytes(1)
                          08                    # "\b"
                       D7                       # tag(23)
                          45                    # bytes(5)
                             1234567890         # "\x124Vx\x90"
                       41                       # bytes(1)
                          09                    # "\t"
                       68                       # text(8)
                          4A6F686E20446F65      # "John Doe"
                       41                       # bytes(1)
                          0A                    # "\n"
                       F5                       # primitive(21)
                 41                             # bytes(1)
                    02                          # "\x02"
                 D5                             # tag(21)
                    58 20                       # bytes(32)
                       4C9540F793AB33B13670169BDF444C1EB1C37047F18
                       E861981E14E34587B1E04 # "L\x95@\xF7\x93\xAB3
                       \xB16p\x16\x9B\xDFDL\x1E\xB1\xC3pG\xF1\x8E
                       \x86\x19\x81\xE1N4X{\x1E\x04"
              01                                # unsigned(1)

7.  IANA Considerations

7.1.  CBOR Tags

   The IANA is requested to assign the following tags from the "CBOR
   Tags" registry defined in RFC 7049 [RFC7049]:




Miller & Saint-Andre    Expires November 6, 2017               [Page 12]

                                  JSCN                          May 2017


   o  Assign the tag "Constrained JSON" in the 1 to 23 value range (one
      byte in length when encoded).

   o  Assign the tag "Upper Case Modifier" in the 24 to 255 value range
      (two bytes in length when encoded).

   The tags to be assigned are described below.

      Tag             20 (Constrained JSON)
      Data Item       array
      Semantics       The first value in the array is a constrained
                      JSON data item encoded using JSCN, optionally
                      followed by an integer or array identifying any
                      embedded references, and then an optional array
                      of whitespace hints (if any).
      Reference       http://quartzjer.github.io/JSCN
      Contact         Jeremie Miller <jeremie.miller@gmail.com>

      Tag             31 (Upper Case Modifier)
      Data Item       multiple
      Semantics       Indicates that the data item following contains
                      values where the upper case is semantically
                      important when interpreted in a UTF-8 string
                      context.
      Reference       http://quartzjer.github.io/JSCN
      Contact         Jeremie Miller <jeremie.miller@gmail.com>

7.2.  JSCN Reference Sets Registry

   A future version of this document will request creation of a registry
   for JSCN Reference Sets.

8.  Security Considerations

   TODO

9.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
              2003, <http://www.rfc-editor.org/info/rfc3629>.





Miller & Saint-Andre    Expires November 6, 2017               [Page 13]

                                  JSCN                          May 2017


   [RFC7049]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", RFC 7049, DOI 10.17487/RFC7049,
              October 2013, <http://www.rfc-editor.org/info/rfc7049>.

   [RFC7159]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, DOI 10.17487/RFC7159, March
              2014, <http://www.rfc-editor.org/info/rfc7159>.

   [RFC7228]  Bormann, C., Ersue, M., and A. Keranen, "Terminology for
              Constrained-Node Networks", RFC 7228,
              DOI 10.17487/RFC7228, May 2014,
              <http://www.rfc-editor.org/info/rfc7228>.

   [RFC7515]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", RFC 7515, DOI 10.17487/RFC7515, May
              2015, <http://www.rfc-editor.org/info/rfc7515>.

   [RFC7516]  Jones, M. and J. Hildebrand, "JSON Web Encryption (JWE)",
              RFC 7516, DOI 10.17487/RFC7516, May 2015,
              <http://www.rfc-editor.org/info/rfc7516>.

   [RFC7517]  Jones, M., "JSON Web Key (JWK)", RFC 7517,
              DOI 10.17487/RFC7517, May 2015,
              <http://www.rfc-editor.org/info/rfc7517>.

   [RFC7518]  Jones, M., "JSON Web Algorithms (JWA)", RFC 7518,
              DOI 10.17487/RFC7518, May 2015,
              <http://www.rfc-editor.org/info/rfc7518>.

   [RFC7519]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web Token
              (JWT)", RFC 7519, DOI 10.17487/RFC7519, May 2015,
              <http://www.rfc-editor.org/info/rfc7519>.

Appendix A.  Acknowledgements

   Thanks to Carsten Bormann for his comments.

Authors' Addresses

   Jeremie Miller

   Email: jeremie@jabber.org


   Peter Saint-Andre

   Email: stpeter@jabber.org




Miller & Saint-Andre    Expires November 6, 2017               [Page 14]
