<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>JSON Constrained Representation (JCOR)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 CBOR Encoding"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Structured Types"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Primitive Types"/>
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Boolean and Null"/>
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Numbers"/>
<link href="#rfc.section.2.2.3" rel="Chapter" title="2.2.3 Strings"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Reference Sets"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Canonical Form"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Formatting-only Whitespace"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 String Escapes"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Constrained API"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Examples"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 JSON"/>
<link href="#rfc.section.6.1.1" rel="Chapter" title="6.1.1 Input"/>
<link href="#rfc.section.6.1.2" rel="Chapter" title="6.1.2 Optimized JCOR Encoding"/>
<link href="#rfc.section.6.1.3" rel="Chapter" title="6.1.3 Un-optimized JCOR Encoding"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 JSON Web Token"/>
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 CBOR Tags"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 JCOR Reference Sets Registry"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations"/>
<link href="#rfc.references" rel="Chapter" title="9 References"/>
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Acknowledgements"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Miller, J. and P. Saint-Andre" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-miller-json-constrained-representation-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-1-13" />
  <meta name="dct.abstract" content="This specification addresses the challenges of using JavaScript Object Notation (JSON) with constrained devices by providing a standard set of mapping rules to Concise Binary Object Representation (CBOR) that preserve all semantic information, such that the original JSON string can be identically re-created.  JSON Constrained Representation (JCOR) can also be used by devices as a native data format, which can then be represented as JSON when necessary for diagnostics, compatibility, and ease of integration with higher-level systems.  " />
  <meta name="description" content="This specification addresses the challenges of using JavaScript Object Notation (JSON) with constrained devices by providing a standard set of mapping rules to Concise Binary Object Representation (CBOR) that preserve all semantic information, such that the original JSON string can be identically re-created.  JSON Constrained Representation (JCOR) can also be used by devices as a native data format, which can then be represented as JSON when necessary for diagnostics, compatibility, and ease of integration with higher-level systems.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">J. Miller</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right"></td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">P. Saint-Andre</td>
</tr>
<tr>
  <td class="left">Expires: July 17, 2018</td>
  <td class="right">January 13, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">JSON Constrained Representation (JCOR)<br />
  <span class="filename">draft-miller-json-constrained-representation-00</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This specification addresses the challenges of using JavaScript Object Notation (JSON) with constrained devices by providing a standard set of mapping rules to Concise Binary Object Representation (CBOR) that preserve all semantic information, such that the original JSON string can be identically re-created.  JSON Constrained Representation (JCOR) can also be used by devices as a native data format, which can then be represented as JSON when necessary for diagnostics, compatibility, and ease of integration with higher-level systems.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on July 17, 2018.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Terminology</a></li>
</ul><li>2.   <a href="#rfc.section.2">CBOR Encoding</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Structured Types</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Primitive Types</a></li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Boolean and Null</a></li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Numbers</a></li>
<li>2.2.3.   <a href="#rfc.section.2.2.3">Strings</a></li>
</ul></ul><li>3.   <a href="#rfc.section.3">Reference Sets</a></li>
<li>4.   <a href="#rfc.section.4">Canonical Form</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Formatting-only Whitespace</a></li>
<li>4.2.   <a href="#rfc.section.4.2">String Escapes</a></li>
</ul><li>5.   <a href="#rfc.section.5">Constrained API</a></li>
<li>6.   <a href="#rfc.section.6">Examples</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">JSON</a></li>
<ul><li>6.1.1.   <a href="#rfc.section.6.1.1">Input</a></li>
<li>6.1.2.   <a href="#rfc.section.6.1.2">Optimized JCOR Encoding</a></li>
<li>6.1.3.   <a href="#rfc.section.6.1.3">Un-optimized JCOR Encoding</a></li>
</ul><li>6.2.   <a href="#rfc.section.6.2">JSON Web Token</a></li>
</ul><li>7.   <a href="#rfc.section.7">IANA Considerations</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">CBOR Tags</a></li>
<li>7.2.   <a href="#rfc.section.7.2">JCOR Reference Sets Registry</a></li>
</ul><li>8.   <a href="#rfc.section.8">Security Considerations</a></li>
<li>9.   <a href="#rfc.references">References</a></li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Acknowledgements</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">Although JavaScript Object Notation (JSON) <a href="#RFC7159">[RFC7159]</a> has been widely adopted in traditional networking and software environments, its use in embedded and constrained environments has been more limited because of the minimal storage and network capacities inherent in low-cost and low-power devices (see <a href="#RFC7228">[RFC7228]</a>).  </p>
<p id="rfc.section.1.p.2">This specification addresses the challenges of using JSON with constrained devices by defining a set of mapping rules to Concise Binary Object Representation (CBOR) <a href="#RFC7049">[RFC7049]</a> that preserve all semantic information, such that the original JSON string can be identically re-created.  JSON Constrained Representation (JCOR) can be used directly by devices as a native data format, which can be represented as JSON when necessary for diagnostics, compatibility, and ease of integration with higher-level systems.  </p>
<p id="rfc.section.1.p.3">A primary goal of JCOR is to enable all JSON Object Signing and Encryption (JOSE) standards (<a href="#RFC7515">[RFC7515]</a>, <a href="#RFC7516">[RFC7516]</a>, <a href="#RFC7517">[RFC7517]</a>, <a href="#RFC7518">[RFC7518]</a>, <a href="#RFC7519">[RFC7519]</a>) to be used unmodified in constrained environments.  One result is that <a href="http://openid.net/connect/">OpenID Connect</a> (which utilizes JSON Web Tokens <a href="#RFC7519">[RFC7519]</a>) can more easily be adopted as an identity management solution for the Internet of Things.  </p>
<p id="rfc.section.1.p.4">JCOR is designed to leverage, not replace, CBOR. Instead, JCOR specifies rules for re-coding JSON structures by mapping them to their CBOR parallels whenever possible, and then increasing the efficiency through introspection and replacement of well-known strings with compact references.  </p>
<p id="rfc.section.1.p.5">All transcoding software MUST operate on a UTF-8 JSON string whenever complete round-trip compatibility to and from JSON is required, including mapping any contained non-structural whitespace (such as with JWTs for signature validation).  If a transcoder is only operating with an already parsed JSON value (the result of <samp>JSON.parse()</samp> in JavaScript for instance), the round-trip can only guarantee semantic compatibility of the values as represented in that parsed context (only the JavaScript object will always match).  </p>
<p id="rfc.section.1.p.6">A significant reduction in space is also provided in JCOR when the device and application contexts can make use of built-in or shared UTF-8 string references.  These references provide a mapping of common JSON string values to an integer that used to replace the string in the resulting CBOR during re-coding.  JSON string values are also introspected for data that has a more compact CBOR type (such as base64url and hexadecimal encoding).  </p>
<p id="rfc.section.1.p.7">The use of this specification can ensure that a UTF-8 JSON string before and after re-coding will be byte-for-byte identical across implementations, whereas the CBOR encoding is not designed to have this property and MAY vary based on implementation choices and reference sets available.  There are basic API rules defined for constrained software such that directly accessing the CBOR data values will always provide a uniform view to an application across variations in the underlying CBOR representation.  </p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#terminology" id="terminology">Terminology</a></h1>
<p id="rfc.section.1.1.p.1">Many terms used in this document are defined in the specifications for JSON <a href="#RFC7159">[RFC7159]</a> and CBOR <a href="#RFC7049">[RFC7049]</a>. This specification defines the following additional terms: </p>
<p/>

<ul>
  <li>Constrained JSON Tag <ul><li>The CBOR tag registered in this specification to indicate an array that contains JSON data encoded as CBOR according to this specification.</li></ul></li>
  <li>Reference <ul><li>A pointer within JCOR data that refers to a well-known UTF-8 string by using a CBOR byte string of length one, where the byte value is the lookup identifier for the Reference.</li></ul></li>
  <li>Reference Set <ul><li>A CBOR array of UTF-8 strings that are used to replace any Reference within any JCOR data, where the Reference identifier is the array offset to the replacement string and the first position in the array identifies the Reference Set.</li></ul></li>
  <li>Canonical Hints <ul><li>A CBOR array of integers that indicate positional offsets for JSON string escape sequences or structural formatting whitespace strings (, <samp>\n</samp>, <samp>\r</samp>, and <samp>\t</samp>) such that when any CBOR encoded data is stringified into JSON it can also optionally be corrected to exactly match the original JSON string.</li></ul></li>
</ul>

<p> </p>
<p id="rfc.section.1.1.p.3">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#cbor-encoding" id="cbor-encoding">CBOR Encoding</a></h1>
<p id="rfc.section.2.p.1">JCOR encodes JSON data types to CBOR data types as described in the following sections.  </p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#structured-types" id="structured-types">Structured Types</a></h1>
<p id="rfc.section.2.1.p.1">JSON defines two structured types: arrays and objects.  These are serialized to CBOR major type 4 (array) and type 5 (map), respectively.  Ordering of key/value pairs in JSON objects and CBOR maps MUST be preserved.  </p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#primitive-types" id="primitive-types">Primitive Types</a></h1>
<h1 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#boolean-and-null" id="boolean-and-null">Boolean and Null</a></h1>
<p id="rfc.section.2.2.1.p.1">The JSON literal names <samp>false</samp>, <samp>true</samp>, and <samp>null</samp> are serialized to the CBOR major type 7 simple values 20, 21, and 22 respectively.  </p>
<h1 id="rfc.section.2.2.2"><a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#numbers" id="numbers">Numbers</a></h1>
<p id="rfc.section.2.2.2.p.1">A JCOR encoder attempts to encode a JSON number as a CBOR unsigned integer (type 0), negative integer (type 1), or float (type 7) and then test for compatibility by round-tripping the CBOR data item back to a JSON number.  If the resulting JSON number is not equivalent to the input number, the encoder MUST instead encode it as a CBOR Bigfloat (tag 5).  </p>
<p id="rfc.section.2.2.2.p.2">The JSON exponent value (if any) is encoded as a CBOR exponent (tag 4).  If the contained <samp>e</samp> symbol is upper case in JSON, the "Upper Case Modifier" tag defined below MUST be included.  </p>
<h1 id="rfc.section.2.2.3"><a href="#rfc.section.2.2.3">2.2.3.</a> <a href="#strings" id="strings">Strings</a></h1>
<p id="rfc.section.2.2.3.p.1">A JSON string is normally encoded as an un-escaped CBOR UTF-8 string (type 3), i.e., as a series of UTF-8 <a href="#RFC3629">[RFC3629]</a> characters (e.g., the word "one" is encoded as "6F6E65") without any backspace escaping for control or unicode characters.  </p>
<h1 id="rfc.section.2.2.3.1"><a href="#rfc.section.2.2.3.1">2.2.3.1.</a> <a href="#base64--base16-encoded" id="base64--base16-encoded">Base64 / Base16 Encoded</a></h1>
<p id="rfc.section.2.2.3.1.p.1">A JCOR encoder MUST round-trip test all JSON strings for possible encodings (base64url, base64, and hexadecimal) by attempting to decode and re-encode them.  If identical byte strings result, the decoded value is tagged in CBOR with the encoding format (tags 21, 22, and 23).  For hexadecimal, the "Upper Case Modifier" tag defined below MUST be included if the hexadecimal letters A-F are upper case in the original JSON string.  </p>
<p id="rfc.section.2.2.3.1.p.2">A JCOR encoder MUST perform introspection on the resulting decoded byte string to determine if it begins with a JSON structure byte of '{' or '['.  The encoder SHOULD then round-trip test the string as a possible JSON object or array so that it can encode the string more efficiently into a CBOR data item instead of a byte string (this pattern is common in the JOSE specification).  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#reference-sets" id="reference-sets">Reference Sets</a></h1>
<p id="rfc.section.3.p.1">The Constrained JSON Tag is followed by an array whose second item identifies the Reference Set used in the data.  This is either a Reference Set identifier or an array that defines an inline Reference Set.  </p>
<p id="rfc.section.3.p.2">A Reference Set identifier is a unique integer that maps to a Reference Set known to applications using the set.  Public, well-known reference sets can be registered as described in the IANA Considerations section of this document.  </p>
<p id="rfc.section.3.p.3">The Reference Set definition is encoded as a JCOR array, where the first value is the Reference Set identifier followed by all of the UTF-8 string keys.  A key's position in the array is the byte value with which it is replaced.  </p>
<p id="rfc.section.3.p.4">Any Reference Set can include another Reference Set by encoding the second set's identifer in the JCOR array that defines the first Reference Set.  Any byte strings in the definition array are then replaced with the key from the references contained in the second Reference Set.  </p>
<p id="rfc.section.3.p.5">JSON UTF-8 strings representing keys or values are first checked against all active references (if any) for possible replacement.  A replacement is always a CBOR byte string (type 2) of length 1, where the single byte represents the index value of the key in the references array from 1-255.  Value 0 and byte lengths greater than 1 are reserved for future use.  </p>
<p id="rfc.section.3.p.6">When a JCOR decoder generates JSON values from CBOR and it encounters a CBOR byte string (type 2), single byte value MUST match the array offset of the active references to be used as the replacement for that byte string.  </p>
<p id="rfc.section.3.p.7">The following is the encoded form of a Reference Set as defined by the JSON array of <samp>[1,"map","value","array","one","two","three","bool","neg","simple","ints"]</samp>: </p>
<pre>
D4                       # tag(20)
   81                    # array(1)
      8B                 # array(11)
         01              # unsigned(1)
         63              # text(3)
            6D6170       # "map"
         65              # text(5)
            76616C7565   # "value"
         65              # text(5)
            6172726179   # "array"
         63              # text(3)
            6F6E65       # "one"
         63              # text(3)
            74776F       # "two"
         65              # text(5)
            7468726565   # "three"
         64              # text(4)
            626F6F6C     # "bool"
         63              # text(3)
            6E6567       # "neg"
         66              # text(6)
            73696D706C65 # "simple"
         64              # text(4)
            696E7473     # "ints"
</pre>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#canonical-form" id="canonical-form">Canonical Form</a></h1>
<p id="rfc.section.4.p.1">This specification directly supports use-cases such as JSON Web Tokens (<a href="#RFC7518">[RFC7518]</a>) where the canonical form of UTF-8 JSON strings always needs to be available for validation.  This is accomplished by optionally including any additional information to reproduce the exact UTF-8 string as an array of Canonical Hints included with the Constrained JSON Tag.  </p>
<p id="rfc.section.4.p.2">These hints are not typically necessary as most machine-generated JSON does not include any extra insignificant bytes by default, even when included they do not need to be processed unless the original canonical form is requested.  When required, these additional hints also take a highly constrained form and are independently additive to the contained CBOR data values such that those values remain uniform to any constrained application.  </p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#formattingonly-whitespace" id="formattingonly-whitespace">Formatting-only Whitespace</a></h1>
<p id="rfc.section.4.1.p.1">When a Constrained JSON tag is present and the first item in the tagged array is a CBOR structure (map or array), a third optional item in the tagged array is a set of canonical whitespace hints for any non-structural whitespace characters contained in the original UTF-8 representation of the JSON object or array.  </p>
<p/>

<ul>
  <li>Whitespace hints are contained in an array of integers that indicate offsets of the locations of whitespace characters in an original JSON string, and lookup values identifying which whitespace characters were there.</li>
  <li>Each offset integer is relative to the position of the previous offset such that all integers are of small values.</li>
  <li>A negative integer offset indicates a single ASCII space character (0x20) at the offset of the positive value of that integer.</li>
  <li>An unsigned integer offset is followed by another integer, where unsigned values (0-23) indicate a whitespace string in the pre-defined lookup table, and negative values specify the number of space characters (0x20) to repeat.</li>
  <li>When re-inserting whitespace characters to a JSON string, the array MUST be applied sequentially so that each new offset matches the original JSON string position.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.p.3">The following 24 whitespace character hexadecimal sequences are used as the shared reference lookup table by row (0-23) when processing whitespace hints.  This table is constructed to minimize the number of references commonly required while also allowing any possible whitespace character sequences to be identified.  </p>
<pre>
0a
0a2020
0a20202020
0a202020202020
0a2020202020202020
0a20202020202020202020
0a202020202020202020202020
0a2020202020202020202020202020
09
0a09
0a0909
0a090909
0a09090909
0a0909090909
0a090909090909
0a09090909090909
0a0909090909090909
0d
0d0a
0d0a2020
0d0a20202020
0d0a09
0d0a0909
0d0a090909
</pre>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#string-escapes" id="string-escapes">String Escapes</a></h1>
<p id="rfc.section.4.2.p.1">JSON string values MAY contain escaped characters (as defined in Section 7 of <a href="#RFC7159">[RFC7159]</a>) that become un-escaped in the process of re-coding them into a CBOR UTF-8 string.  When the canonical form is being preserved and any escaped characters are detected in the process of converting them from JSON to CBOR, those string values MUST be individually tagged as Constrained JSON where the first element in the tagged array is the CBOR UTF-8 string value and the second value is an array of positional integers similar to the whitespace hints.  </p>
<p id="rfc.section.4.2.p.2">When the position is an unsigned integer it indicates the UTF-8 character at that position is to be escaped with the <samp>\uXXXX</samp> form with lower-case hexadecimal characters.  When it is a negative integer it indicates that it is to be escaped with the <samp>\X</samp> form and MUST be in the set of JSON escaped control characters.  </p>
<p id="rfc.section.4.2.p.3">When the original escaping in the <samp>\uXXXX</samp> form was with upper case hexadecimal characters the entire array MUST be tagged with Upper Case Modifier.  In the unlikely case that the original escaping contained mixed-case hexadecimal, then the positional integer will instead itself be an array of length two with the position being the first element and a 4-byte UTF-8 string of the mixed-case hexadecimal value being the second element.  </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#constrained-api" id="constrained-api">Constrained API</a></h1>
<p id="rfc.section.5.p.1">In order to ease the use of JCOR in constrained environments, an implementation SHOULD make data values available both as native CBOR types and as JSON strings; this enables a constrained application to choose either format regardless of how the data is represented in CBOR.  </p>
<p id="rfc.section.5.p.2">For example, when the original JSON string value is encoded as a CBOR base64url tag plus byte string, a constrained application accessing the value as a string MUST receive the base64url encoded value and not the decoded byte value.  If the constrained application instead accesses the value as a byte array it MUST get the decoded value if available.  </p>
<p id="rfc.section.5.p.3">The representation of the value in CBOR SHOULD NOT alter behavior of the application, a string value encoded as tag plus byte array SHOULD NOT be used as an indication that it is a binary value and only the application can make this determination based on external context.  </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#examples" id="examples">Examples</a></h1>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#json" id="json">JSON</a></h1>
<h1 id="rfc.section.6.1.1"><a href="#rfc.section.6.1.1">6.1.1.</a> <a href="#input" id="input">Input</a></h1>
<p id="rfc.section.6.1.1.p.1">Consider the following JSON as input to a JCOR encoder.  </p>
<pre>
{
  "map": "value",
  "array": [
    "one",
    "two",
    "three",
    42
  ],
  "bool": true,
  "neg": -42,
  "simple": [
    false,
    null,
    ""
  ],
  "ints": [
    0,
    1,
    23,
    24,
    255,
    256,
    65535,
    65536,
    4294967295,
    4294967296,
    281474976710656,
    -281474976710656
  ]
}
</pre>
<h1 id="rfc.section.6.1.2"><a href="#rfc.section.6.1.2">6.1.2.</a> <a href="#optimized-jcor-encoding" id="optimized-jcor-encoding">Optimized JCOR Encoding</a></h1>
<p id="rfc.section.6.1.2.p.1">An optimized encoding would remove whitespace and use a Reference Set. Here the references would be: </p>
<p><samp>[1,"map","value","array","one","two","three","bool","neg","simple","ints"]</samp> </p>
<p id="rfc.section.6.1.2.p.3">The resulting JCOR encoding is 90 bytes compared to 318 bytes for the JSON input.  </p>
<pre>
D4                              # tag(20)
   82                           # array(2)
      A6                        # map(6)
         41                     # bytes(1)
            01                  # "\x01"
         41                     # bytes(1)
            02                  # "\x02"
         41                     # bytes(1)
            03                  # "\x03"
         84                     # array(4)
            41                  # bytes(1)
               04               # "\x04"
            41                  # bytes(1)
               05               # "\x05"
            41                  # bytes(1)
               06               # "\x06"
            18 2A               # unsigned(42)
         41                     # bytes(1)
            07                  # "\a"
         F5                     # primitive(21)
         41                     # bytes(1)
            08                  # "\b"
         38 29                  # negative(41)
         41                     # bytes(1)
            09                  # "\t"
         83                     # array(3)
            F4                  # primitive(20)
            F6                  # primitive(22)
            60                  # text(0)
                                # ""
         41                     # bytes(1)
            0A                  # "\n"
         8C                     # array(12)
            00                  # unsigned(0)
            01                  # unsigned(1)
            17                  # unsigned(23)
            18 18               # unsigned(24)
            19 00FF             # unsigned(255)
            19 0100             # unsigned(256)
            19 FFFF             # unsigned(65535)
            1A 00010000         # unsigned(65536)
            1B 00000000FFFFFFFF # unsigned(4294967295)
            1B 0000000100000000 # unsigned(4294967296)
            1B 0001000000000000 # unsigned(281474976710656)
            3B 0000FFFFFFFFFFFF # negative(281474976710655)
      01                        # unsigned(1)
</pre>
<h1 id="rfc.section.6.1.3"><a href="#rfc.section.6.1.3">6.1.3.</a> <a href="#unoptimized-jcor-encoding" id="unoptimized-jcor-encoding">Un-optimized JCOR Encoding</a></h1>
<p id="rfc.section.6.1.3.p.1">An un-optimized encoding would not use a Reference Set and would preserve whitespace. The un-optimized encoding would reduce the data from the 318 bytes (JSON) to 187 bytes (JCOR).  </p>
<pre>
D4                              # tag(20)
   83                           # array(3)
      A6                        # map(6)
         63                     # text(3)
            6D6170              # "map"
         65                     # text(5)
            76616C7565          # "value"
         65                     # text(5)
            6172726179          # "array"
         84                     # array(4)
            63                  # text(3)
               6F6E65           # "one"
            63                  # text(3)
               74776F           # "two"
            65                  # text(5)
               7468726565       # "three"
            18 2A               # unsigned(42)
         64                     # text(4)
            626F6F6C            # "bool"
         F5                     # primitive(21)
         63                     # text(3)
            6E6567              # "neg"
         38 29                  # negative(41)
         66                     # text(6)
            73696D706C65        # "simple"
         83                     # array(3)
            F4                  # primitive(20)
            F6                  # primitive(22)
            60                  # text(0)
                                # ""
         64                     # text(4)
            696E7473            # "ints"
         8C                     # array(12)
            00                  # unsigned(0)
            01                  # unsigned(1)
            17                  # unsigned(23)
            18 18               # unsigned(24)
            19 00FF             # unsigned(255)
            19 0100             # unsigned(256)
            19 FFFF             # unsigned(65535)
            1A 00010000         # unsigned(65536)
            1B 00000000FFFFFFFF # unsigned(4294967295)
            1B 0000000100000000 # unsigned(4294967296)
            1B 0001000000000000 # unsigned(281474976710656)
            3B 0000FFFFFFFFFFFF # negative(281474976710655)
      00                        # unsigned(0)
      98 40                     # array(64)
         01                     # unsigned(1)
         01                     # unsigned(1)
         26                     # negative(6)
         08                     # unsigned(8)
         01                     # unsigned(1)
         28                     # negative(8)
         01                     # unsigned(1)
         02                     # unsigned(2)
         06                     # unsigned(6)
         02                     # unsigned(2)
         06                     # unsigned(6)
         02                     # unsigned(2)
         08                     # unsigned(8)
         02                     # unsigned(2)
         02                     # unsigned(2)
         01                     # unsigned(1)
         02                     # unsigned(2)
         01                     # unsigned(1)
         27                     # negative(7)
         05                     # unsigned(5)
         01                     # unsigned(1)
         26                     # negative(6)
         04                     # unsigned(4)
         01                     # unsigned(1)
         29                     # negative(9)
         01                     # unsigned(1)
         02                     # unsigned(2)
         06                     # unsigned(6)
         02                     # unsigned(2)
         05                     # unsigned(5)
         02                     # unsigned(2)
         02                     # unsigned(2)
         01                     # unsigned(1)
         02                     # unsigned(2)
         01                     # unsigned(1)
         27                     # negative(7)
         01                     # unsigned(1)
         02                     # unsigned(2)
         02                     # unsigned(2)
         02                     # unsigned(2)
         02                     # unsigned(2)
         02                     # unsigned(2)
         03                     # unsigned(3)
         02                     # unsigned(2)
         03                     # unsigned(3)
         02                     # unsigned(2)
         04                     # unsigned(4)
         02                     # unsigned(2)
         04                     # unsigned(4)
         02                     # unsigned(2)
         06                     # unsigned(6)
         02                     # unsigned(2)
         06                     # unsigned(6)
         02                     # unsigned(2)
         0B                     # unsigned(11)
         02                     # unsigned(2)
         0B                     # unsigned(11)
         02                     # unsigned(2)
         10                     # unsigned(16)
         02                     # unsigned(2)
         10                     # unsigned(16)
         01                     # unsigned(1)
         01                     # unsigned(1)
         00                     # unsigned(0)
</pre>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#json-web-token" id="json-web-token">JSON Web Token</a></h1>
<p id="rfc.section.6.2.p.1">Consider the following JSON Web Token <a href="#RFC7519">[RFC7519]</a>, which natively is 149 bytes (line endings are not significant): </p>
<pre>
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiO
iIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWR
taW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZ
geFONFh7HgQ
</pre>
<p id="rfc.section.6.2.p.2">In a JSON encoding, the JWT would be 191 bytes (line endings are not significant): </p>
<pre>
{"protected":
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
"payload":"eyJzdWIiOiIxMjM0NTY3ODkwIiwib
mFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9",
"signature":
"TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh
7HgQ"}
</pre>
<p id="rfc.section.6.2.p.3">Using a Reference Set of <samp>[1,"payload","signature","protected","alg","HS256","sub","name","admin"]</samp>, the JCOR encoding would be 80 bytes.  </p>
<pre>
D4                                      # tag(20)
   82                                   # array(2)
      A3                                # map(3)
         41                             # bytes(1)
            03                          # "\x03"
         D5                             # tag(21)
            A2                          # map(2)
               41                       # bytes(1)
                  04                    # "\x04"
               41                       # bytes(1)
                  05                    # "\x05"
               41                       # bytes(1)
                  06                    # "\x06"
               41                       # bytes(1)
                  07                    # "\a"
         41                             # bytes(1)
            01                          # "\x01"
         D5                             # tag(21)
            A3                          # map(3)
               41                       # bytes(1)
                  08                    # "\b"
               D7                       # tag(23)
                  45                    # bytes(5)
                     1234567890         # "\x124Vx\x90"
               41                       # bytes(1)
                  09                    # "\t"
               68                       # text(8)
                  4A6F686E20446F65      # "John Doe"
               41                       # bytes(1)
                  0A                    # "\n"
               F5                       # primitive(21)
         41                             # bytes(1)
            02                          # "\x02"
         D5                             # tag(21)
            58 20                       # bytes(32)
               4C9540F793AB33B13670169BDF444C1EB1C37047F18
               E861981E14E34587B1E04 # "L\x95@\xF7\x93\xAB3
               \xB16p\x16\x9B\xDFDL\x1E\xB1\xC3pG\xF1\x8E
               \x86\x19\x81\xE1N4X{\x1E\x04"
      01                                # unsigned(1)
</pre>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#cbor-tags" id="cbor-tags">CBOR Tags</a></h1>
<p id="rfc.section.7.1.p.1">The IANA is requested to assign the following tags from the "CBOR Tags" registry defined in RFC 7049 <a href="#RFC7049">[RFC7049]</a>: </p>
<p/>

<ul>
  <li>Assign the tag "Constrained JSON" in the 1 to 23 value range (one byte in length when encoded).</li>
  <li>Assign the tag "Upper Case Modifier" in the 24 to 255 value range (two bytes in length when encoded).</li>
</ul>

<p> </p>
<p id="rfc.section.7.1.p.3">The tags to be assigned are described below.  </p>
<pre>
Tag             20 (Constrained JSON)
Data Item       array
Semantics       The first value in the array is a constrained 
                JSON data item encoded using JCOR, optionally 
                followed by an integer or array identifying any 
                embedded references, and then an optional array 
                of canonical hints (if any).
Reference       http://quartzjer.github.io/JCOR
Contact         Jeremie Miller &lt;jeremie.miller@gmail.com&gt;

Tag             31 (Upper Case Modifier)
Data Item       multiple
Semantics       Indicates that the data item following contains 
                values where the upper case is semantically 
                important when interpreted in a UTF-8 string 
                context.
Reference       http://quartzjer.github.io/JCOR
Contact         Jeremie Miller &lt;jeremie.miller@gmail.com&gt;
</pre>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#jcor-reference-sets-registry" id="jcor-reference-sets-registry">JCOR Reference Sets Registry</a></h1>
<p id="rfc.section.7.2.p.1">A future version of this document will request creation of a registry for JCOR Reference Sets and provide initial registrations for the existing JOSE JWE, JWS, and JWA RFCs.  </p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.8.p.1">TODO </p>
<h1 id="rfc.references"><a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3629">[RFC3629]</b>
      </td>
      <td class="top"><a>Yergeau, F.</a>, "<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7049">[RFC7049]</b>
      </td>
      <td class="top"><a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="http://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>", RFC 7049, DOI 10.17487/RFC7049, October 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7159">[RFC7159]</b>
      </td>
      <td class="top"><a>Bray, T.</a>, "<a href="http://tools.ietf.org/html/rfc7159">The JavaScript Object Notation (JSON) Data Interchange Format</a>", RFC 7159, DOI 10.17487/RFC7159, March 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7515">[RFC7515]</b>
      </td>
      <td class="top"><a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="http://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a>", RFC 7515, DOI 10.17487/RFC7515, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7516">[RFC7516]</b>
      </td>
      <td class="top"><a>Jones, M.</a> and <a>J. Hildebrand</a>, "<a href="http://tools.ietf.org/html/rfc7516">JSON Web Encryption (JWE)</a>", RFC 7516, DOI 10.17487/RFC7516, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7517">[RFC7517]</b>
      </td>
      <td class="top"><a>Jones, M.</a>, "<a href="http://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a>", RFC 7517, DOI 10.17487/RFC7517, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7518">[RFC7518]</b>
      </td>
      <td class="top"><a>Jones, M.</a>, "<a href="http://tools.ietf.org/html/rfc7518">JSON Web Algorithms (JWA)</a>", RFC 7518, DOI 10.17487/RFC7518, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7519">[RFC7519]</b>
      </td>
      <td class="top"><a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="http://tools.ietf.org/html/rfc7519">JSON Web Token (JWT)</a>", RFC 7519, DOI 10.17487/RFC7519, May 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC7228">[RFC7228]</b>
      </td>
      <td class="top"><a>Bormann, C.</a>, <a>Ersue, M.</a> and <a>A. Keranen</a>, "<a href="http://tools.ietf.org/html/rfc7228">Terminology for Constrained-Node Networks</a>", RFC 7228, DOI 10.17487/RFC7228, May 2014.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.A.p.1">Thanks to Carsten Bormann and David Waite for their comments.  </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jeremie Miller</span> 
	  <span class="n hidden">
		<span class="family-name">Miller</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jeremie@jabber.org">jeremie@jabber.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Peter Saint-Andre</span> 
	  <span class="n hidden">
		<span class="family-name">Saint-Andre</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:stpeter@jabber.org">stpeter@jabber.org</a></span>

  </address>
</div>

</body>
</html>
